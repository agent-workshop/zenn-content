---
title: "LLM・LLM・LLMを「チーム」にしたら、1人で開発するより3倍速くなった話"
emoji: "🤖"
type: "tech"
topics: ["ai", "自動化", "typescript", "mcp", "個人開発"]
published: true
---
## はじめに

AIに「全部やって」と頼むと、実装は意外とうまく回りません。
この記事では、AIを「PM・実装・レビュー」に分けるだけで安定する方法を、実稼働コード付きで解説します。
無料パートだけでMCPサーバーを10分で再現できます。

**無料パート（第1〜3章）:**
- なぜAIは「1人」より「チーム」が強いのか
- MCPとは何か、なぜHTTP APIでは不十分なのか
- 動くMCPサーバーを10分で作る手順

**有料パート（第4〜6章）:**
- AIの出力品質を数値管理する「納得テスト」の全実装
- エージェント同士を会話させるオーケストレーターコード
- 実際に踏んだ3つの地雷と回避法

---

## 第1章: AIエージェントは「1人」より「チーム」が強い

### 単体エージェントの限界
ChatGPTやLLMのWeb UIを使っているとき、こんな経験はありませんか？
「要件定義をして、設計をして、コードを書いて、テストもして」と一度に頼むと、後半のタスクがおざなりになる現象。

これは、LLM（大規模言語モデル）の **「注意機構（Attention）」の限界** です。
一度に処理できるコンテキスト（文脈）には限りがあり、タスクが複雑になればなるほど、モデルの注意力は散漫になります。

### 役割分担（Role-based）のメリット
そこで有効なのが、**「役割分担」** です。
人間社会でも、1人で企画・営業・開発・経理をこなすのは困難ですが、チームなら可能です。AIも同じです。

私たちのチーム構成は以下の通りです。

1.  **PMエージェント**: 全体の進行管理、タスクの分解、優先順位付け。
2.  **実装エージェント**: 具体的なコードの記述、リファクタリング。
3.  **レビューエージェント**: コードの品質チェック、バグ発見、設計の妥当性評価。
4.  **リサーチエージェント**: 外部情報の収集、トレンド調査。

このように役割を分けることで、各エージェントは「自分の仕事」に集中でき、結果として全体のパフォーマンスが向上します。
特に重要なのが **「相互レビュー」** です。実装エージェントが書いたコードを、別の視点（レビューエージェント）がチェックすることで、単純なミスやハルシネーション（嘘の出力）を劇的に減らすことができます。

---

## 第2章: MCPでつなぐ脳と手足

### MCP (Model Context Protocol) とは？
「MCP」という言葉を聞いたことはありますか？
これは、**AIモデル（脳）と、外部のデータやツール（手足）をつなぐための標準規格** です。

これまで、AIに外部ツールを使わせるには、LangChainや各社の独自Function Callingを駆使して、複雑なグルーミングコードを書く必要がありました。
しかし、MCPを使えば、**「MCPサーバー」として定義したツールやリソースを、あらゆるMCP対応クライアント（LLM Desktopアプリや、自作のエージェント）から統一的に利用できる** ようになります。

### なぜHTTP APIじゃダメなのか？
「普通のREST APIでいいじゃん」と思うかもしれません。
しかし、MCPにはAI特化の利点があります。

1.  **プロンプト情報の自動提供**: サーバー側から「このツールはどう使うべきか」という説明（プロンプト）を動的に提供できます。
2.  **リソースの抽象化**: ファイルの中身、DBのレコード、APIのレスポンスなどを「リソース」として統一的に扱えます。
3.  **ステートフルな接続**: JSON-RPCベースの双方向通信により、セッションを通じた対話的なやり取りが可能です。

### サーバーとクライアントの関係
私たちのシステムでは、以下のような構成でMCPを活用しています。

- **MCPサーバー**: ファイル操作、SQLiteデータベース操作、Web検索、ブラウザ操作などの「機能」を提供。
- **MCPクライアント**: 各AIエージェント（PM・実装・レビュー・リサーチなど）。必要に応じてサーバーに接続し、道具を使う。

例えば、「日次レポートを作成する」というタスクの場合：
1. PMエージェントが「データベース閲覧ツール」を使って売上データを取得。
2. 実装エージェントが「ファイル操作ツール」を使ってMarkdownファイルを作成。
3. レビューエージェントが「ファイル読み込みツール」を使って内容を確認。

このように、MCPサーバーを介してエージェントたちが「同じ道具」「同じデータ」を共有することで、スムーズな連携が可能になります。

---

## 第3章: 実装の第一歩 〜最小構成のMCPサーバー〜

では、実際にコードを書いてみましょう。
ここでは、TypeScriptとBunを使って、**「簡単な計算機能を提供するMCPサーバー」** を作ります。

### プロジェクトのセットアップ
まず、プロジェクトを作成し、必要なライブラリをインストールします。
私たちは `bun` を推奨しますが、`npm` でも同様に可能です。

```bash
mkdir mcp-demo
cd mcp-demo
bun init
bun add @modelcontextprotocol/sdk zod
```

### サーバーの実装 (server.ts)
`@modelcontextprotocol/sdk` を使えば、驚くほど簡単にサーバーが書けます。

```typescript
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";

// サーバーインスタンスの作成
const server = new McpServer({
  name: "calc-server",
  version: "1.0.0",
});

// ツールの登録: 加算
server.tool(
  "add",
  "2つの数値を足し算します",
  {
    a: z.number().describe("1つ目の数値"),
    b: z.number().describe("2つ目の数値"),
  },
  async ({ a, b }) => {
    return {
      content: [{ type: "text", text: String(a + b) }],
    };
  }
);

// サーバーの起動 (標準入出力を使用)
const transport = new StdioServerTransport();
await server.connect(transport);

console.error("Calculator MCP Server running on stdio");
```

### クライアントからの利用 (client.ts)
次に、このサーバーを利用するクライアント（エージェント側）のコードです。
ここではシンプルに、ツールを呼び出す部分だけを実装します。

```typescript
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { StdioClientTransport } from "@modelcontextprotocol/sdk/client/stdio.js";

// サーバープロセスをサブプロセスとして起動
const transport = new StdioClientTransport({
  command: "bun",
  args: ["run", "server.ts"],
});

const client = new Client(
  { name: "example-client", version: "1.0.0" },
  { capabilities: {} }
);

await client.connect(transport);

// ツール一覧の取得
const tools = await client.listTools();
console.log("Available tools:", tools.tools.map(t => t.name));

// ツールの実行
const result = await client.callTool({
  name: "add",
  arguments: { a: 10, b: 20 },
});

console.log("Result:", result.content[0].text); // "30"
```

### 実行してみる
```bash
bun run client.ts
```
これだけで、**「クライアントがサーバーのツールを認識し、引数を渡して実行し、結果を受け取る」** という一連の流れが完了しました。

実際の開発では、このクライアント部分に LLM（OpenAI APIやAnthropic API）を組み込み、**「LLMがツールを選んで実行する」** 仕組みを作ります。
それこそが、AIエージェントの「手足」となるのです。

---

ここまでの内容で、MCPサーバーを自作し、AIにツールを使わせる基本は身につきました。
ここから先では、**納得テストの全実装コード**、**エージェント間連携のオーケストレーター**、**実際に踏んだ3つの地雷と回避法**を公開します。
今日中に再現したい方は、このまま続きを読んでください。

---

詳細版は note の有料版で公開しています: https://note.com/agent_workshop
